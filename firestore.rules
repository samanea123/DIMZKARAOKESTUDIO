/**
 * @fileoverview Firestore Security Rules for the Karaoke System.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for song queue items, where each user can only manage their own queue.
 * The songs collection is publicly readable.
 * User profiles are private and only accessible to the respective user.
 *
 * Data Structure:
 * - /songs/{songId}: Stores song metadata (title, artist, album cover). Publicly readable.
 * - /users/{userId}: Stores user profile information.
 * - /users/{userId}/songQueueItems/{songQueueItemId}: Stores song queue items for each user.
 *
 * Key Security Decisions:
 * - Public song list: The `songs` collection is publicly readable, allowing all users to browse available songs.
 * - User-owned queues: Each user manages their own song queue under their user document.
 * - User profiles: User profiles are private and accessible only to the authenticated user.
 * - No user listing: Listing all users is not permitted.
 *
 * Denormalization for Authorization:
 * - The `songQueueItems` subcollection benefits from path-based authorization. The path `/users/{userId}/songQueueItems/{songQueueItemId}` inherently links the queue item to the user, eliminating the need for additional `get()` calls to verify ownership.
 *   The `userId` is part of the path, making `isOwner(userId)` simple and efficient.
 *
 * Structural Segregation:
 * - Song queue items are stored in a private subcollection under each user's document, ensuring that only the user can access their own queue.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read the list of songs, but only allows admins to create, update, or delete them.
     * @path /songs/{songId}
     * @allow (get, list): if true;
     * @deny (create, update, delete): Always denies, as only admins can create, update, and delete them.
     * @principle Public read, owner-only writes (requires schema update)
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows a user to read, update, and delete their own user profile.
     * @path /users/{userId}
     * @allow (get): User with matching {userId} can read their profile.
     * @allow (create): User can create their own profile if the userId matches their auth.uid.
     * @allow (update): User with matching {userId} can update their profile.
     * @allow (delete): User with matching {userId} can delete their profile.
     * @deny (get, update, delete): Always denies if the userId does not match the request.auth.uid.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
      allow list: if false;
    }

    /**
     * @description Allows a user to manage their own song queue items.
     * @path /users/{userId}/songQueueItems/{songQueueItemId}
     * @allow (create): User with matching {userId} can create a song queue item.
     * @allow (get, list): User with matching {userId} can read their song queue items.
     * @allow (update): User with matching {userId} can update their own song queue items.
     * @allow (delete): User with matching {userId} can delete their own song queue items.
     * @deny (create, get, list, update, delete): Always denies if the userId does not match the request.auth.uid.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/songQueueItems/{songQueueItemId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(userId) && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.userId == request.auth.uid;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
        return request.auth.uid == userId;
    }

   function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource != null;
    }
  }
}
/**
 * @fileoverview Firestore Security Rules for Karaoke System
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for song queue items,
 * allowing users to manage their own queues. Song data is publicly accessible.
 * User profiles are also only accessible to the user.
 *
 * Data Structure:
 * - /songs/{songId}: Stores publicly available song metadata.
 * - /users/{userId}: Stores user profile information, accessible only to the user.
 * - /users/{userId}/songQueueItems/{songQueueItemId}: Stores song queue items,
 *   owned and managed by the specific user.
 *
 * Key Security Decisions:
 * - Song metadata is publicly readable but not writable.
 * - Users can only read and write their own profile data.
 * - Song queue items are strictly user-owned, based on the path.
 *
 * Denormalization for Authorization:
 * - The path `/users/{userId}/songQueueItems/{songQueueItemId}` enforces
 *   ownership, making rules simpler and more efficient. No `get()` calls
 *   are needed to validate ownership of queue items.
 *
 * Structural Segregation:
 * - Public song data is separated from private user queue data, allowing
 *   for efficient and secure `list` operations on public data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read-only access to song metadata.
     * @path /songs/{songId}
     * @allow get, list: Any user can read song data.
     * @deny create, update, delete: No one can create, update, or delete song data through the client.
     * @principle Public read, no write access.
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Restricts access to user profiles to the owning user.
     * @path /users/{userId}
     * @allow get: User can get their own profile data.
     * @allow create: User can create their own profile (self-registration).
     * @allow update: User can update their own profile data.
     * @allow delete: User can delete their own profile data.
     * @deny list: User cannot list all users.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for song queue items.
     * @path /users/{userId}/songQueueItems/{songQueueItemId}
     * @allow get, list: User can read their own queue items.
     * @allow create: User can create queue items in their own queue.
     * @allow update: User can update queue items in their own queue.
     * @allow delete: User can delete queue items from their own queue.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/songQueueItems/{songQueueItemId} {
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }
  }

  // --- Helper Functions ---

  /**
   * @description Checks if the request is authenticated.
   * @return {bool} True if the request is authenticated.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the authenticated user ID matches the provided user ID.
   * @param {string} userId The user ID to compare against.
   * @return {bool} True if the authenticated user is the owner.
   */
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  /**
   * @description Checks if the authenticated user is the owner of an existing document.
   * @param {string} userId The user ID to compare against.
   * @return {bool} True if the authenticated user is the owner and the document exists.
   */
  function isExistingOwner(userId) {
    return isSignedIn() && isOwner(userId) && resource != null;
  }
}